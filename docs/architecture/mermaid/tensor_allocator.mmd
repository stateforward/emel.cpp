stateDiagram-v2
  [*] --> idle
  idle --> validating : emel::tensor_allocator::event::allocate_tensors [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_allocate_tensors>
  validating --> validating : emel::tensor_allocator::event::validate [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::run_validate>
  validating --> scanning_tensors : emel::tensor_allocator::events::validate_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::no_error>] / boost::sml::front::none
  validating --> failed : emel::tensor_allocator::events::validate_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::has_error>] / boost::sml::front::none
  validating --> failed : emel::tensor_allocator::events::validate_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::record_phase_error>
  scanning_tensors --> scanning_tensors : emel::tensor_allocator::event::scan_tensors [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::run_scan_tensors>
  scanning_tensors --> partitioning_ranges : emel::tensor_allocator::events::scan_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::no_error>] / boost::sml::front::none
  scanning_tensors --> failed : emel::tensor_allocator::events::scan_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::has_error>] / boost::sml::front::none
  scanning_tensors --> failed : emel::tensor_allocator::events::scan_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::record_phase_error>
  partitioning_ranges --> partitioning_ranges : emel::tensor_allocator::event::partition_ranges [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::run_partition_ranges>
  partitioning_ranges --> allocating_ranges : emel::tensor_allocator::events::partition_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::no_error>] / boost::sml::front::none
  partitioning_ranges --> failed : emel::tensor_allocator::events::partition_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::has_error>] / boost::sml::front::none
  partitioning_ranges --> failed : emel::tensor_allocator::events::partition_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::record_phase_error>
  allocating_ranges --> allocating_ranges : emel::tensor_allocator::event::allocate_ranges [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::run_allocate_ranges>
  allocating_ranges --> initializing_tensors : emel::tensor_allocator::events::allocate_ranges_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::no_error>] / boost::sml::front::none
  allocating_ranges --> failed : emel::tensor_allocator::events::allocate_ranges_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::has_error>] / boost::sml::front::none
  allocating_ranges --> failed : emel::tensor_allocator::events::allocate_ranges_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::record_phase_error>
  initializing_tensors --> initializing_tensors : emel::tensor_allocator::event::initialize_tensors [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::run_initialize_tensors>
  initializing_tensors --> assembling_result : emel::tensor_allocator::events::initialize_tensors_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::no_error>] / boost::sml::front::none
  initializing_tensors --> failed : emel::tensor_allocator::events::initialize_tensors_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::has_error>] / boost::sml::front::none
  initializing_tensors --> failed : emel::tensor_allocator::events::initialize_tensors_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::record_phase_error>
  assembling_result --> assembling_result : emel::tensor_allocator::event::assemble [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::run_assemble>
  assembling_result --> done : emel::tensor_allocator::events::assemble_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::no_error>] / boost::sml::front::none
  assembling_result --> failed : emel::tensor_allocator::events::assemble_done [boost::sml::aux::zero_wrapper<emel::tensor_allocator::guard::has_error>] / boost::sml::front::none
  assembling_result --> failed : emel::tensor_allocator::events::assemble_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::record_phase_error>
  done --> idle : emel::tensor_allocator::events::allocate_done [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::on_allocate_done>
  failed --> idle : emel::tensor_allocator::events::allocate_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::on_allocate_error>
  idle --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  validating --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  scanning_tensors --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  partitioning_ranges --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  allocating_ranges --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  initializing_tensors --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  assembling_result --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  done --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  failed --> releasing : emel::tensor_allocator::event::release [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::begin_release>
  releasing --> idle : emel::tensor_allocator::events::release_done [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::on_release_done>
  releasing --> failed : emel::tensor_allocator::events::release_error [boost::sml::front::always] / boost::sml::aux::zero_wrapper<emel::tensor_allocator::action::on_release_error>
