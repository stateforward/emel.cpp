stateDiagram-v2
  direction TB
  [*] --> emel__tensor__allocator__idle
  emel__tensor__allocator__idle --> emel__tensor__allocator__validating : emel__tensor__allocator__event__allocate_tensors [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_allocate_tensors_
  emel__tensor__allocator__validating --> emel__tensor__allocator__validate_decision : [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__run_validate_
  emel__tensor__allocator__validate_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__validate_decision --> emel__tensor__allocator__scanning_tensors : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__scanning_tensors --> emel__tensor__allocator__scan_decision : [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__run_scan_tensors_
  emel__tensor__allocator__scan_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__scan_decision --> emel__tensor__allocator__partitioning_ranges : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__partitioning_ranges --> emel__tensor__allocator__partition_decision : [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__run_partition_ranges_
  emel__tensor__allocator__partition_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__partition_decision --> emel__tensor__allocator__allocating_ranges : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__allocating_ranges --> emel__tensor__allocator__allocate_decision : [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__run_allocate_ranges_
  emel__tensor__allocator__allocate_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__allocate_decision --> emel__tensor__allocator__initializing_tensors : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__initializing_tensors --> emel__tensor__allocator__initialize_decision : [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__run_initialize_tensors_
  emel__tensor__allocator__initialize_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__initialize_decision --> emel__tensor__allocator__assembling_result : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__assembling_result --> emel__tensor__allocator__assemble_decision : [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__run_assemble_
  emel__tensor__allocator__assemble_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__assemble_decision --> emel__tensor__allocator__done : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__done --> emel__tensor__allocator__idle : [boost__sml__front__always] / boost__sml__front__none
  emel__tensor__allocator__errored --> emel__tensor__allocator__idle : [boost__sml__front__always] / boost__sml__front__none
  emel__tensor__allocator__idle --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__validating --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__validate_decision --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__scanning_tensors --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__scan_decision --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__partitioning_ranges --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__partition_decision --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__allocating_ranges --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__allocate_decision --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__initializing_tensors --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__initialize_decision --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__assembling_result --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__assemble_decision --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__done --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__errored --> emel__tensor__allocator__release_decision : emel__tensor__allocator__event__release [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__begin_release_
  emel__tensor__allocator__release_decision --> emel__tensor__allocator__errored : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_failed_] / boost__sml__front__none
  emel__tensor__allocator__release_decision --> emel__tensor__allocator__idle : [boost__sml__aux__zero_wrapper_emel__tensor__allocator__guard__phase_ok_] / boost__sml__front__none
  emel__tensor__allocator__idle --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__validating --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__validate_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__scanning_tensors --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__scan_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__partitioning_ranges --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__partition_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__allocating_ranges --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__allocate_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__initializing_tensors --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__initialize_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__assembling_result --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__assemble_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__done --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__errored --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
  emel__tensor__allocator__release_decision --> emel__tensor__allocator__errored : boost__sml__back___ [boost__sml__front__always] / boost__sml__aux__zero_wrapper_emel__tensor__allocator__action__on_unexpected_
